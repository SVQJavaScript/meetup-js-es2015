<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>JS.now - Cómo aprovechar ES2015 hoy</title>
  <link href="https://fonts.googleapis.com/css?family=Raleway:200,400,700|Source+Sans+Pro:300,400,700" rel="stylesheet">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/atom-one-dark.min.css">
  <link rel="stylesheet" type="text/css" href="styles/styles.css">
</head>
<body>
  <main class="slideshow">
    <!-- <section></section> -->
    <section>
      <header class="big">
        <h1>JS.now</h1>
        <h2>Cómo aprovechar ES2015 hoy</h2>
      </header>
    </section>
    <!-- <section>
      <header><h3><em>ES¿qué?</em></h3></header>
      <article>
        <p>ES2015 o ES6 es la sexta revision (la quinta publicada) de <strong>ECMAScript</strong>, el lenguaje en el que se basa JavaScript, entre otros.</p>
        <p>Oficialmente llamado <strong>ECMAScript 2015</strong>, se publicó en su versión definitiva en Junio de 2016.</p>
        <p>La versión anterior, <strong>ES5</strong>, se presentó en Diciembre de 2009 y se revisó en Junio de 2011.</p>
      </article>
      <footer></footer>
    </section>
    <section>
      <header><h3><em>ES¿qué?</em></h3></header>
      <article>
        <p>ES2015 ofrece muchas mejoras necesarias para la magnitud que cada vez más está ganando JavaScript, como por ejemplo:</p>
        <ul>
          <li>Clases y módulos</li>
          <li>Iteradores y generadores</li>
          <li>Funciones "Flecha" <em>(Arrow functions)</em></li>
          <li>Nuevos tipos de dato (octal, binario,...) y funciones matemáticas</li>
          <li>Colecciones <em>(maps, sets, weak maps)</em></li>
          <li>Mejoras en procesamiento asíncrono <em>(promise)</em></li>
          <li>Otros agregador y mejoras de <strong>sintaxis</strong>...</li>
        </ul>
      </article>
      <footer></footer>
    </section>
    <section>
      <header><h3>¿Puedo usarlo ya?</h3></header>
      <article class="columns-2">
        <p>ES2015 tiene un soporte bastante extendido, <em>aunque no completo</em>, en motores JS actuales, todo dependerá de quién tenga que ejecutar tu código.</p>
        <p>Existen características de ES2015 muy extendidas que soportan navegadores como Internet Explorer, y otras que ni siquiera Google Chrome las implementa aún.</p>
        <p class="break-before">Soporte <em>muy muy simplificado</em>:</p>
        <ul>
          <li>Internet Explorer (v8 - v11): <span class="bad">✗</span></li>
          <li>Microsoft Edge (v13+): <span class="good">✓</span></li>
          <li>Google Chome (v52+) / Opera (v39+): <span class="good">✓</span></li>
          <li>Mozilla Firefox (v50+): <span class="good">✓</span></li>
          <li>Apple Safari (v10): <span class="good">✓</span></li>
          <li>iOS browser (v9): <span class="moderate">⚠</span></li>
          <li>Android browser (v4.4-): <span class="bad">✗</span>/<span class="moderate">⚠</span></li>
          <li>Android (v5+ <em>Chrome webview</em>): <span class="good">✓</span></li>
          <li>NodeJS (v6+): <span class="good">✓</span></li>
          <li>KinomaXS (v6+): <span class="good">✓</span></li>
        </ul>
      </article>
      <footer></footer>
    </section>
    <section>
      <header><h3><em>"Legacy browsers or ES2015?, that's not the question"</em>, diría Shakespeare</h3></header>
      <article>
        <p>Si tu proyecto tiene que soportar navegadores no tan actuales puedes apoyarte en librerías "traductoras de ES2015" <em>(transpilers)</em> o en <em>Polyfills</em>.</p>
        <p><strong>Librerías traductoras</strong>: permiten desarrollar sobre ES2015, <em>compilando</em> el código original en código compatible con ES5 o anteriores. Como por ejemplo: <a href="https://babeljs.io/" target="_blank">Babel</a>.</p>
        <p><strong>Polyfill</strong>: Ofrece una implementación de una característica de ES2015 sobre ES5 o anteriores compatible a nivel API, <strong>sólo en caso de que el entorno de ejecución no la soporte</strong>. Algunos ejemplos: <a href="https://github.com/stefanpenner/es6-promise" target="_blank">ES6-Promise</a> (sólo para promise), <a href="https://github.com/zloirock/core-js" targer="_blank">Core-JS</a>.</p>
      </article>
      <footer></footer>
    </section>
    <section>
      <header><h3>Polyfills</h3></header>
      <article class="">
        <p>El mecanismo para crear un polyfill es muy sencillo, sólo necesitas comprobar si la función está soportada en el entorno de ejecución actual y si no es así, declarar tu función compatible:</p>
        <pre><code class="js">
// String.prototype.trimStart
if(String.prototype.trimStart === undefined){
  String.prototype.trimStart = function(){
    return this.replace(/^\s*/,'');
  };
}
// versión corta
''.trimStart || (String.prototype.trimStart = function(){
    return this.replace(/^\s*/,'');
});
        </code></pre>
      </article>
      <footer></footer>
    </section>
    <section>
      <header class="big">
        <h1>Sintaxis</h1>
        <h2>Algunas novedades</h2>
      </header>
    </section>
    <section>
      <header><h3>Ámbito de bloque</h3></header>
      <article>
        <p>La técnica más común para limitar el ámbito de una variable hasta ahora era el uso de las <strong>funciones anónimas inmediatamente invocadas</strong> también llamadas <em>IIFE (Inmediatly Invoked Function Expressions)</em></p>
        <pre><code class="js">
var a = 'Exterior';
(function(){
  var a = 'Interior';
  console.log(a);
})();
console.log(a);
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Ámbito de bloque</h3></header>
      <article>
        <p>Ahora podemos limitar el ámbito usando bloques mediante llaves <strong>{ ... }</strong> y la declaración de variables mediante <strong>let</strong>.</p>
        <pre><code class="js">
var a = 'Exterior';
{
  let a = 'Interior';
  console.log(a);
}
console.log(a);
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Pecualiaridades de let</h3></header>
      <article>
        <audio src="metal_gear-alert.mp3"></audio>
        <p><strong>TDZ</strong> o <em>Temporal Dead Zone</em></p>
        <pre><code class="js">
console.log(a);
var a = 'Exterior';
        </code></pre>
        <pre><code class="js">
{
  console.log(a); // Reference Error
  let a = 'Interior';
}
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Bucles for con let</h3></header>
      <article>
        <p>La declaración de la variable a iterar con <strong>let</strong> permite disponer de una variable redeclarada para cada iteración dentro del bloque.</p>
        <pre><code class="js">
var funcs = [];
for (let i = 0; i < 5; i++) {
  funcs.push( function(){
    console.log( i );
  } );
}
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Constantes</h3></header>
      <article>
        <p>Una constante no es más que una variable a la que sólo se puede establecer su valor en su declaración. En caso de querer modificarse lanzará una excepción.</p>
        <pre><code class="js">
const a = 10;
a = 11;
        </code></pre>
        <p>Pero si es de un tipo "complejo", sí es posible modificar su contenido (aunque no esté recomendado).</p>
        <pre><code class="js">
const a = [1,2,3];
a.push(4);
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Funciones dentro bloques</h3></header>
      <article>
        <p>Como con let, podemos declarar funciones accesibles sólo desde dentro del bloque.</p>
        <pre><code class="js">
'use strict';
{
  saludo();

  function saludo(){
    console.log('hola!');
  }
}

saludo();
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Funciones dentro bloques</h3></header>
      <article>
        <audio src="metal_gear-alert.mp3"></audio>
        <p>Hay que tener cuidado si estamos acostumbrados a escribir funciones de esta forma:</p>
        <pre><code class="js">
'use strict';
let foo = 'nope';
if(foo === 'bar'){
  function test(){
    console.log('Test para bar');
  }
}else{
  function test(){
    console.log('Test para otra cosa');
  }
}

test();
        </code></pre>
      </article>
    </section>


    <section>
      <header><h3>Operador ...</h3></header>
      <article>
        <p>Normalmente llamado operador de propagación (<strong>Spread</strong>) u operador <strong>Rest</strong> según dónde se encuentre.</p>
        <pre><code class="js">
// Spread
var a = [1,2,3];
console.log(a);
console.log(...a);

// Rest
function logAll(...z){
  console.log(z);
}
logAll(1,2,3,4,5,6,7,8,9,10);
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Operador ...</h3></header>
      <article>
        <p>En realidad responde a la estandarización del objeto <em>arguments</em> que se mantenía por retrocompatibilidad pero no se recomendaba su uso intensivo.</p>
        <p>La principal diferencia entre los parametros <em>rest</em> y el objeto <em>arguments</em> es que el primero sí es un array; mientras que el segundo es un objeto con algunas propiedades de array, como <em>length</em>.</p>
        <pre><code class="js">
function logAllArguments(){
  console.log(arguments);
}
logAll(1,2,3,4,5,6,7,8,9,10);
logAllArguments(1,2,3,4,5,6,7,8,9,10);
        </code></pre>
      </article>
    </section>


    <section>
      <header><h3>Valores por defecto en funciones</h3></header>
      <article>
        <p>
          Casi siempre hemos usado la fórmula
          <pre><code class="js">
variable = variable || 10;
          </code></pre>
          o las variantes
          <pre><code class="js">
// Para evitar que 0 se ignore
variable = (variable !== undefined) ? variable : 10;
          </code></pre>
          o
          <pre><code class="js">
// Sólo detectar si se ha pasado parametro o no
variable = (0 in arguments) ? variable : 10;
          </code></pre>
        </p>
      </article>
    </section>
    <section>
      <header><h3>Valores por defecto en funciones</h3></header>
      <article>
        <p>Ahora <em>por fin</em> podemos indicar un valor por defecto usando la fórmula</p>
        <pre><code class="js">
function suma(a = 10, b = 20){
  return a + b;
}
suma(2,3);
suma(8);
suma();
suma(undefined, 6);
suma(null, 6);
suma(,6);
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Valores por defecto en funciones</h3></header>
      <article>
        <p>Además de valores estáticos, podemos usar expresiones para asignaciones por defecto</p>
        <pre><code class="js">
function cuadrado(x){
  return x * x;
}
function sumaCuadrado(a = 5, b = cuadrado(a)){
  return a + b;
}
sumaCuadrados(2);
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Peculiaridades en valores por defecto</h3></header>
      <article>
        <audio src="metal_gear-alert.mp3"></audio>
        <ul>
          <li>
            <p>Los parámetros tipo <strong>rest</strong> no pueden tener un valor por defecto</p>
            <pre><code class="js">
function test(...z = [1,2,3]){
  console.log(z); // Unexpected token
}
test();
            </code></pre>
          </li>
          <li>
            <p>Tienen un ámbito propio reservando los nombres de los parámetros</p>
            <pre><code class="js">
var z = 9;
function test(z = z + 1){
  console.log(z);
}
test(); // Reference error
            </code></pre>
          </li>
        </ul>
      </article>
    </section>


    <section>
      <header><h3>Desestructuración</h3></header>
      <article>
        <p>Permite asignar valores a distintas variables desde las posiciones de un array o las propiedades de un objeto. Muy útil para permitir devolver varios valores separados en variables desde la misma función.</p>
        <pre><code class="js">
function foo() {
  return [1,2,3];
}
// Pre-ES2015
var tmp = foo(),
    a = tmp[0], b = tmp[1], c = tmp[2];
console.log(a, b, c); // 1 2 3

// ES2015
var [x,y,z] = foo();
console.log(x, y, z); // 1 2 3
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Desestructuración. Objetos.</h3></header>
      <article>
        <audio src="metal_gear-alert.mp3"></audio>
        <p>La función es muy similar usando objetos, pero ojo, <strong>la asignación está invertida</strong>.</p>
        <pre><code class="js">
function foo() {
  return {a: 1, b: 2, c: 3};
}
var {a:x, b:y, c:z} = foo(); // propiedad del objeto: nombre de la variable
console.log(x, y, z); // 1 2 3
        </code></pre>
        <p>También es válido para variables que ya existan.</p>
        <pre><code class="js">
var d,e,f;
( {a:d, b:e, c:f} = foo() );
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Desestructuración. Objetos.</h3></header>
      <article>
        <p>Cuando las variables y las propiedades a asignar tienen el mismo nombre, podemos abreviar la asignación:</p>
        <pre><code class="js">
function foo() {
  return {a: 1, b: 2, c: 3};
}
var {a, b, c} = foo();
console.log(a, b, c);
        </code></pre>
        <p>Esto puede aprovecharse de forma inversa para asignar propiedades a un objeto cuando estas se llamen igual que las variables a asignar.</p>
        <pre><code class="js">
var a = 1, b = 2, c = 3;
var x = {a ,b, c};
console.log(x);
        </code></pre>
      </article>
    </section> -->
    <!-- var arr = [ 40, 1, 5, 200 ]; -->
    <!-- arr.sort((a,b)=>a-b);  // [ 1, 5, 40, 200 ] -->


    <section>
      <header><h3>Mejoras en Objetos. Métodos abreviados.</h3></header>
      <article>
        <p>En la definición de un método para un objeto solemos crear <strong>funciones anónimas</strong> que asignamos a una clave que le da nombre, pero ahora podemos usar una <strong>sintaxis abreviada</strong> para definirlas y dejar un código más limpio.</p>
        <pre><code class="js">
// Pre-ES2015
var oldObj = {
  myMethod: function() { console.log('Hola!'); }
}

// ES2015
let newObj = {
  myMethod() { console.log('Hola!'); }
}
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Mejoras en Objetos. Generadores.</h3></header>
      <article>
        <p></p>
        <pre><code class="js">

        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Mejoras en Objetos. Get y Set.</h3></header>
      <article>
        <p></p>
        <pre><code class="js">

        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Mejoras en Objetos. Funciones flecha.</h3></header>
      <article>
        <p></p>
        <pre><code class="js">

        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Mejoras en Objetos. Valores por defecto.</h3></header>
      <article>
        <p></p>
        <pre><code class="js">

        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Mejoras en Objetos. Clases.</h3></header>
      <article>
        <p>Hasta ahora la creacion de <em>clases</em> era cuanto menos, poco ortodoxa</p>
        <pre><code class="js">
// Pre-ES2015 (una de las formas posibles)
function MyClass(x, y) {
  this.x = x;
  this.y = y;
}
MyClass.prototype.doSomething = function() {
  console.log("I did something");
}

let myObj = new MyClass(1,2);
myObj.doSomething();
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Mejoras en Objetos. Clases.</h3></header>
      <article>
        <p>Pero ahora podemos declararlas, <em>por fin</em>, como <strong>clases</strong> de una forma más parecida a otros lenguajes</p>
        <pre><code class="js">
// ES2015
class MyNewClass {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  doSomething() {
    console.log("I did something");
  }
}

let myNewObj = new MyNewClass(1,2);
myNewObj.doSomething();
        </code></pre>
      </article>
    </section>
    <section>
      <header><h3>Mejoras en Objetos. Herencia.</h3></header>
      <article>
        <p>La herencia de clases se vuelve también más sencilla gracias a <strong>extends</strong> y <strong>super</strong>.</p>
        <pre><code class="js">
class ParentClass {
  constructor(x) { this.x = x; }
  operateX() { return this.x * this.x; }
}

class ChildClass extends ParentClass {
  constructor(x,y) {
    super(x);
    this.y = y;
  }
  operateX() {
    let tempX = super.operateX();
    return tempX + this.y;
  }
}
        </code></pre>
      </article>
    </section>

    <section>
      <header></header>
      <article class="columns-2">
        <img src="http://lorempixel.com/200/400/technics" />
        <p>Quisque tellus felis, lacinia quis condimentum at, mollis vel nibh. Vivamus sit amet ligula accumsan, laoreet urna at, blandit massa. Nulla vel posuere lectus. Pellentesque in mauris feugiat, ullamcorper dolor eget, dictum lorem. Suspendisse quis quam quis libero pulvinar lacinia nec ac neque. Nunc ornare lacinia malesuada. Nulla ut rhoncus nibh. Integer eros mauris, efficitur eget dolor quis, dapibus semper leo.</p>
        <p>Praesent lacinia mi scelerisque pretium cursus.</p>
      </article>
      <footer></footer>
    </section>
  </main>
  <nav>
    <a href="#" id="prevSlide">Prev</a>
    <a href="#" id="nextSlide">Next</a>
  </nav>
  <script src="js/highlight.pack.js"></script>
  <script src="js/slideshow.js"></script>
</body>
</html>
